pipeline {
    agent any

    environment {
        K8S_NAMESPACE = "default"
        // Use one of these methods to get Minikube IP:
        // MINIKUBE_IP = sh(script: "minikube ip", returnStdout: true).trim()  // If minikube is on Jenkins host
        MINIKUBE_IP = "192.168.49.2"  // For Docker Desktop (Mac/Windows)
        // MINIKUBE_IP = "192.168.49.2"  // Only if you're sure this is correct
        MINIKUBE_PATH = "${WORKSPACE}/minikube-config"  // Using workspace instead of /tmp
    }

    stages {
        stage('Clean Workspace') {
            steps {
                sh '''
                    rm -rf "${MINIKUBE_PATH}" || true
                    mkdir -p "${MINIKUBE_PATH}"
                '''
            }
        }

        stage('Verify Minikube Connectivity') {
            steps {
                script {
                    // Verify we can reach Minikube
                    def reachable = sh(
                        script: "curl -k -m 5 https://${MINIKUBE_IP}:8443 || echo 'unreachable'", 
                        returnStdout: true
                    ).trim()
                    
                    if (reachable.contains('unreachable')) {
                        error("Cannot reach Minikube at ${MINIKUBE_IP}:8443. Check if Minikube is running.")
                    }
                }
            }
        }

        stage('Deploy to Minikube') {
            steps {
                withCredentials([
                    file(credentialsId: 'kubeconfig-credentials-id', variable: 'KUBECONFIG_FILE'),
                    file(credentialsId: 'minikube-ca', variable: 'MINIKUBE_CA'),
                    file(credentialsId: 'minikube-cert', variable: 'MINIKUBE_CERT'),
                    file(credentialsId: 'minikube-key', variable: 'MINIKUBE_KEY')
                ]) {
                    script {
                        sh """
                            # Copy credentials
                            cp "${KUBECONFIG_FILE}" "${MINIKUBE_PATH}/kubeconfig"
                            cp "${MINIKUBE_CA}" "${MINIKUBE_PATH}/ca.crt"
                            cp "${MINIKUBE_CERT}" "${MINIKUBE_PATH}/client.crt"
                            cp "${MINIKUBE_KEY}" "${MINIKUBE_PATH}/client.key"

                            # Update kubeconfig
                            sed -i "s|server: .*|server: https://${MINIKUBE_IP}:8443|g" "${MINIKUBE_PATH}/kubeconfig"
                            sed -i "s|/minikube/|${MINIKUBE_PATH}/|g" "${MINIKUBE_PATH}/kubeconfig"

                            # Test connection first
                            export KUBECONFIG="${MINIKUBE_PATH}/kubeconfig"
                            kubectl config view
                            kubectl version --client
                            
                            # Wait for cluster to be responsive
                            timeout 60 bash -c "until kubectl cluster-info; do sleep 2; done" || {
                                echo "Failed to connect to cluster"
                                exit 1
                            }

                            # Deploy
                            kubectl apply -f k8s/deployment.yml -n ${K8S_NAMESPACE}
                            kubectl apply -f k8s/service.yml -n ${K8S_NAMESPACE}
                            kubectl apply -f k8s/ingress.yml -n ${K8S_NAMESPACE} || echo "ℹ️ No ingress.yml found"
                            kubectl rollout status deployment/eureka-server -n ${K8S_NAMESPACE} --timeout=120s
                        """
                    }
                }
            }
        }
    }
}